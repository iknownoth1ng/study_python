#!/usr/bin/env python
# -*- encoding: utf-8 -*-
'''
@File    :   gcIII.py
@Time    :   2022/06/23 11:14:17
@Author  :   owl
@Email   :   xxxxx@163.com
@Desp    :   垃圾回收
'''

# here put the import lib
'''
1. Garbage collection(GC垃圾回收)
现在的高级语言如java，c#等，都采用了垃圾收集机制，而不再是c，c++里用户自己管理维护内存的方式。
自己管理内存极其自由，可以任意申请内存，但如同一把双刃剑，为大量内存泄露，悬空指针等bug埋下隐患。
对于一个字符串、列表、类甚至数值都是对象，且定位简单易用的语言，自然不会让用户去处理如何分配回收内存的问题。 
python里也同java一样采用了垃圾收集机制，不过不一样的是: python采用的是引用计数机制为主，分代收集机制为辅的策略
'''

'''
引用计数机制的优点：
简单
实时性：一旦没有引用，内存就直接释放了。
不用像其他机制等到特定时机。
实时性还带来一个好处：处理回收内存的时间分摊到了平时。

引用计数机制的缺点：
维护引用计数消耗资源
循环引用
'''


'''
GC系统所承担的工作远比"垃圾回收"多得多。实际上，它们负责三个重要任务。它们
为新生成的对象分配内存
识别哪些是垃圾对象
回收垃圾对象占用的内存'''


'''1、导致引用计数+1的情况
对象被创建，例如a=23
对象被引用，例如b=a
对象被作为参数，传入到一个函数中，例如func(a)
对象作为一个元素，存储在容器中，例如list1=[a,a]
2、导致引用计数-1的情况
对象的别名被显式销毁，例如del a
对象的别名被赋予新的对象，例如a=24
一个对象离开它的作用域，例如f函数执行完毕时，func函数中的局部变量（全局变量不会）
对象所在的容器被销毁，或从容器中删除对象
'''
# 3、查看一个对象的引用计数
import sys

a = "hello world"
sys.getrefcount(a)
